# -*- coding: utf-8 -*-
from NNetwork import NNetwork
"""REU2020.ipynb
Automatically generated by Colaboratory.
Original file is located a 
    https://colab.research.google.com/drive/1NFiB2XR-a5Y-D8yz-7OpPYMM4tU-cnWF
### [pip install necessary libraries and mounting Google Drive working directories]
"""

""" Fun Colors"""

fun_colors = ['Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 
'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 
'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 
'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 
'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 
'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 
'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 
'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 
'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 
'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 
'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 
'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 
'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'cubehelix', 'cubehelix_r', 
'flag', 'flag_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 
'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 
'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 
'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 
'hot_r', 'hsv', 'hsv_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 
'magma_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 
'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 
'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 
'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 
'terrain', 'terrain_r', 'twilight', 'twilight_r', 'twilight_shifted', 
'twilight_shifted_r', 'viridis', 'viridis_r', 'winter', 'winter_r']

"""# Color Network (NNetwork subclass)
# Notes
Stochastics and width lemma demonstration on iterations
"""

# import libraries
import numpy as np
import imageio
import networkx as nx
from NNetwork import NNetwork
from math import floor, pow
from scipy.stats import bernoulli
import time, random, io
from matplotlib import pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.colors as colors
from PIL import Image
from tqdm import tqdm

def time_format(seconds):
    minutes = 0 
    if seconds / 60 > 1:
        return(str(floor(seconds/60)) + " min. " + \
               str(round(seconds % 60,3)) + " sec.")
    return("0 min. " + str(round(seconds,3)) + " sec.")

# --------------------------- #
# Color list NNetwork extension
# --------------------------- #
class ColorNNetwork(NNetwork):
    
    """
    Specific case of NNetwork, 
    ***assumes 1-n {0,n-1} vertices uniquely labeled 
    each with its own coloring***
    """

    def __init__(self, colors=[],edges=[]):
        
        super().__init__()
        self.colors = colors
        self.add_edges(edges)
        self.mst_edges = []

    def get_color(self, v):
        """
        gets color of vertex
        """
        return self.colors[v]
    
    def get_colors(self):
        """
        returns colors of corresponding vertices
        i.e. we get each color
        """
        return self.colors
    
    def get_neighbor_colors(self, v):
        """
        gets set of colors of neighbors
        """
        neighbs = self.neighbors(v)
        
        return list(map(self.get_color,list(neighbs)))
    
    def set_color(self, v, col):
        """
        sets color of vertex
        """
        self.colors[v-1] = col
    
    def set_colors(self, color_list):
        """
        Assigns new colors corresponding to each vertex by index
        """
        self.colors = color_list
        

# --------------------------- #
# FCA Implementation 
# --------------------------- #
def simulate_FCA(G, kappa, its = int(pow(2,32)-1), verbose=True, tree=False, 
                 stochastic=0, refractory=False, animate=0, trackdelay=False,
                 name=0, timesec=30, gifduration=200):
    """
    Function that returns edgelist color changes for FCA
    Useful for visualization
    """
    # initial conditions
    blink = floor((kappa-1)/2) # blink color and lower bound on post-blink     
    F = G
    # used for tree diameter
    tree_edges = G.edges
    
    # set arrays used by tree_iter
    if tree:
        parentlist = [None] * G.num_nodes()
        values = np.random.rand(G.num_nodes())

    # local helper function
    def new_color(vertex):
        neighblist = F.get_neighbor_colors(vertex)  

        if stochastic == 1 or stochastic == 3:
            # stochastic reception 
            k = sum(bernoulli.rvs(0.5, size=len(neighblist)))
            neighblist = random.sample(neighblist,k)
        
        if(F.get_color(vertex) > blink and \
           any(np.array(neighblist) == blink)):
            if stochastic == 2 or stochastic == 3:
                # stochastic emission 
                if any(bernoulli.rvs(0.5,size=
                        sum(np.array(neighblist)==blink))):
                    return F.get_color(vertex)
            if (trackdelay and (F.get_color(vertex) >= kappa-1)):
                return kappa
            else:
                # deterministic pulse
                return F.get_color(vertex)
        if (F.get_color(vertex) == kappa):
            return 0
        return (F.get_color(vertex) + 1) % kappa

    # animate function
    def make_gif(its):
        if animate: 
            grapher(new_col, F.get_edges(), colormap, animate)
            buf = io.BytesIO()
            plt.savefig(buf, format='png')
            buf.seek(0)
            im = Image.open(buf)
            images.append(im)
            plt.close()
    
    # looping condition until convergence for set tolerance
    count_reached = 1 
    s = time.time()
    current_colors = [F.get_colors()]
    images = []; colormap = color_scheme(kappa)
    for i in tqdm(range(1, its+1), disable=not verbose):
        # perform updates for each vertex
        new_col = list(map(new_color, range(0, F.num_nodes())))

        mylist = current_colors[-1]
        # check synchronization -> break and return final list and iterations
        if(all(np.array(mylist) == mylist[0]) and i % kappa == blink):
            if animate:
                make_gif(0)
                if name == 0:
                    print("User must provide name for animation save.")
                name = 'stoch'+str(stochastic)+'ref'+str(refractory)+'_'+ name
                tail = images[1:]; tail.extend([images[-1] for i in range(0,5)])
                images[0].save(name+'.gif', save_all=True, 
                    append_images=tail, optimize=False, duration=gifduration, loop=0)

            if verbose: print("Iterations: " + str(i)+'\n'+'Time: ' + \
                              time_format(round(time.time()-s, 3)) + '\n')

            return [current_colors, count_reached, i, tree_edges]

        if(time.time() - s > timesec and i % kappa == 1):

            print("Stopping condition for time has been met: ",time.time()-s,"sec.")

            return [current_colors, count_reached, i, tree_edges]

        # refractory condition step
        if refractory:
            # check for unchanged color frequency
            if sorted(current_colors[-1]) == sorted(new_col):
                index = np.where(
                  np.array(current_colors[-1]) == np.array(new_col))[0]
                for i in list(index):
                      new_col[i] = (F.get_color(i) + 1) % kappa
        if(i == its):
            count_reached = 0
            
        # spanning tree construction
        if tree:
            values, parentlist = tree_iter(G, values, parentlist)
            tree = not (len(G.edges) == G.num_nodes()-1)
            
            if not tree:
                tree_edges = G.edges
            if (len(G.edges)<G.num_nodes()-1):
                print("deleted too many edges")
            

        # Final update and append
        current_colors.append(new_col)
        F.set_colors(new_col)
        #uncomment line below to enable iteration by iteration animation    
        make_gif(i) 
    
    # Maximum iteration reached output/return variation
    if verbose: 
        print("Maximum iterations reached: " + str(its) + \
              '\n' + 'Time: ' + time_format(round(time.time()-s, 3)) + '\n')
        
    if animate:
        make_gif(0)
        if name == 0:
            print("User must provide name for animation save.")
        name = 'stoch'+str(stochastic)+'ref'+str(refractory)+'_'+ name
        tail = images[1:]; tail.extend([images[-1] for i in range(0,5)])
        images[0].save(name+'.gif', save_all=True, 
            append_images=tail, optimize=False, duration=gifduration, loop=0)
    return [current_colors, count_reached, its, tree_edges]


def basic_FCA(G, kappa, its = int(pow(2,32)-1), verbose=True, timesec=0, tree=False, no_edges=0):
    
    # initial conditions
    blink = floor((kappa-1)/2) # blink color and lower bound on post-blink     
    colors = []
    init_col = G.get_colors()
    colors.append(init_col)
    if tree:
        parentlist = [None] * G.num_nodes()
        values = np.random.rand(G.num_nodes())
    # local helper function
    def new_color(vertex):
        neighblist = G.get_neighbor_colors(vertex)  

        if(G.get_color(vertex) > blink and \
           any(np.array(neighblist) == blink)):
             return G.get_color(vertex)
        return (G.get_color(vertex) + 1) % kappa
    
    # initial coloring and start time
    current_col = G.get_colors()
    width_compute(current_col, kappa)
    s = time.time()
    for i in range(1, its+1):
        # perform updates for each vertex
        current_col = list(map(new_color, range(0, G.num_nodes())))

        # check synchronization -> break and return final list and iterations
        width = width_compute(current_col,kappa)
        if(width < floor(kappa/2)):
            if verbose: print("Iterations: ",i)
            if no_edges:
                    
                return np.array([-1, init_col, 1, colors, i])

            return np.array([G.edges, init_col, 1, colors, i])

        if timesec and time.time()-s > timesec:
            if verbose:
                print("Iterations: ",i)
                print("Time has been reached: ", timesec,"sec.")
            if no_edges:
                return np.array([-1, init_col, 0, colors, i])
            return np.array([G.edges, init_col, 0, colors, i])
        # update to new colors
        G.set_colors(current_col)
        colors.append(np.array(G.get_colors()))
        if tree:
            values, parentlist = tree_iter(G, values, parentlist)
            tree = not (len(G.edges) == G.num_nodes()-1)
            if (len(G.edges)<G.num_nodes()-1):
                print("deleted too many edges")

    if verbose: 
        print("Max iterations reached: ", its)
    if no_edges:
        return np.array([-1, init_col, 0, colors, i])
    return np.array([G.edges, init_col, 0, colors, i])


def width_compute(coloring, kappa):
    differences = [np.max(coloring) - np.min(coloring)]
    for j in range(1,kappa+1):
        shifted = (np.array(coloring) + j) % kappa
        differences.append(np.max(shifted) - np.min(shifted))
    #print(np.min(differences))
    return np.min(differences)


# ---------------------------------- #
# Clock Synchronization Algorithm
# ---------------------------------- #
def delete_edge(graph,edge):
# temporary edge deletion method
    u, v = edge
    if u in graph.neighb and v in graph.neighb[u]:
        graph.neighb[u].remove(v)
    if v in graph.neighb and u in graph.neighb[v]:
        graph.neighb[v].remove(u)
    for i in range(len(graph.edges)):
        if graph.edges[i] == [u,v]:
            graph.edges.pop(i)
            break


# step updating tree, occurs during each color iteration
# end when values elements all the same
# values are values between 0 and 1
def tree_iter(graph,values,parentlist):
    newvalues = values.copy()
    newparents = parentlist.copy()
    for node in graph.vertices:
        neighbors = graph.neighbors(node).copy()
        if parentlist[node] is not None:
            neighbors.remove(parentlist[node])
            outgoing = neighbors
            newvalues[node] = newvalues[parentlist[node]]
        else:
            outgoing = neighbors
        # make sure that outgoing is not Nonetype
        if outgoing is None:
            continue
        #iterate over neighbors minus parent
        for neigh in outgoing:
            selfnum = newvalues[node]
            neighnum = values[neigh]
            if neighnum > selfnum:
                newparents[node] = neigh
                newvalues[node] = neighnum
            elif (neighnum == selfnum) & (parentlist[neigh] is None):
                deleteedge = [min(node,neigh),max(node,neigh)]
                delete_edge(graph,deleteedge)
            elif (neighnum == selfnum) & (not parentlist[neigh] == node):
                deleteedge = [min(node,neigh),max(node,neigh)]
                delete_edge(graph,deleteedge)

    return newvalues, newparents


# --------------------------# 
# Display Graphics Function #
# --------------------------#
def sync_display(coloring, kappa, cstyle=0, name=0):

    if cstyle == 0: 
        cstyle=random.sample(fun_colors,1)[0]
        x=coloring[::kappa]
    if len(x) % kappa != 0 and isinstance(x, np.ndarray):
        np.append(x, coloring[-1])
    elif len(x) % kappa !=0 and isinstance(x, list):
        x.append(coloring[-1])
        
    # generate plt object    
    plt.pcolormesh(x, cmap=cstyle)
    plt.gca().invert_yaxis()
    fig = plt.gcf()
    plt.show()
    if name:
        name = "col" + str(kappa) + "_" + name
        fig.savefig(name)
        return 0

# ----------------------------#
#   Color Scheme Generator 
# ----------------------------#
def color_scheme(kappa):
    random_spectrum = [("%06x" % random.randrange(10**80))[:6]
                     for i in range(0,kappa)]
    cs = {key:('#'+str(col)) for key, col in enumerate(random_spectrum)}
    return cs

def grapher(colors, edges, cs, animate):
    verts = list(range(0, len(colors)))
    G = nx.Graph()
    G.add_nodes_from(verts)

    if animate == 1:
        pos = nx.circular_layout(G)
    else:
        pos = nx.spring_layout(G, seed=12)
    cmap = cs
    for node in verts:
        nx.draw_networkx_nodes(G, pos, [verts[node]], 
                        node_color=cs[colors[node]], node_size=400, alpha=0.8)
    G.add_edges_from(edges)
    nx.draw_networkx_edges(G, pos, width=1, alpha=0.5)
    labels = {}
    for i in range(len(colors)):
        labels[i] = colors[i]
    nx.draw_networkx_labels(G, pos, labels)
    plt.axis('off')
    
    
# --------------------------- #
# Edge list generators
# --------------------------- #
#layers indicate how many layers you want past the initial star. so layers = 1 makes 1 layer past the parents children
def star(children, layers):
    edgelist = []; count = 0
    for i in range(1, children+1):
        edgelist.append([0, i])
        count += 1
    for l in range(0, layers): 
        for j in range(children*l, children*l + children):
            edgelist.append([edgelist[j][1], count + 1])
            count += 1
    return edgelist

def edgeset_generator(dims, type='lattice', verbose=True, show=True,
        linegraphtoo=False):
    #lattice grapher
    mapper = {}
    if type == 'hex':
        edgeset = nx.generators.lattice.hexagonal_lattice_graph(dims[0], dims[1])
        if verbose: print("hex generated")
    elif type == 'tree':
        edgeset = nx.generators.classic.balanced_tree(dims[0], dims[1]) 
        if verbose:print("tree generated")
    elif type == 'star':
        if verbose: print("star generated")
        x = star(dims[0], dims[1])
        numvert = max([i for j in x for i in j])+1
        if verbose: print('The amount of vertices in the graph is: ', numvert)
        return x
    elif type == 'complete':
        edgeset = nx.generators.classic.complete_graph(dims[0])
    elif type == 'er': 
        edgeset = nx.generators.random_graphs.erdos_renyi_graph(dims[0], dims[1])
        if verbose:print("Erdos-Reyni generated")
    elif type == 'cycle':
        edgeset = nx.cycle_graph(dims[0])
        if verbose: print('cycle generated')
    elif type == 'nwg':
        edgeset = nx.newman_watts_strogatz_graph(dims[0], dims[1], dims[2])
        if verbose: print('Connected Watts Strogatz graph generated.')
    elif type == 'torus':
        edgeset = nx.grid_2d_graph(dims[0], dims[1], periodic=True)
        if verbose: print("Torus generated")
    else:
        edgeset = nx.generators.lattice.grid_graph(dim=dims)
        if verbose: print("lattice generated")

    mapper = {key:i for i, key in enumerate(edgeset.nodes)}
    if show:
        nx.draw_networkx_labels(edgeset, nx.spring_layout(edgeset, seed=1024), mapper, font_size=12)
        nx.draw_networkx(edgeset)
        plt.show()

    vertexlist = list(range(0, len(list(edgeset.nodes))))
    if verbose: print('The amount of vertices in the graph is: ', len(vertexlist))

    pre_edge = [e for e in edgeset.edges]
    if linegraphtoo:
        return ([[mapper[pre_edge[j][0]], mapper[pre_edge[j][1]]] \
                    for j in range(0, len(pre_edge))], \
                    nx.line_graph(edgeset))
    return [[mapper[pre_edge[j][0]], mapper[pre_edge[j][1]]] \
                    for j in range(0, len(pre_edge))]


# ------------------------------------- #
# Other plotting metrics
# ------------------------------------- #
def color_statistics(colorlist, kappa, mod=False, every=0, savename=0):

    if every==0:
        every=kappa

    ave = np.mean(colorlist, 1)[::every]
    std = np.std(colorlist, 1)[::every]
    if savename:
        aveline, = plt.plot(ave, 'blue', label='Average Coloring')
        plt.fill_between(np.arange(len(ave)),
                (ave-std), (ave+std), alpha=0.2,color='blue')
        plt.ylabel('Average Colorings')
        plt.xlabel('Every $\kappa$ Iteration')
        blue1 = mpatches.Patch(color='blue', alpha=0.4, label='$\sigma$')
        plt.legend(handles=[aveline, blue1], loc='upper right')
        plt.title('Empirical Distribution of Colors over FCA Simulation')
        plt.savefig(savename+'_k'+str(kappa)+'_mean.png')
        plt.close()
    temp = np.min(ave-std) 
    res = [i for i, j in enumerate(ave-std) if j == temp]
    print(savename)
    print(res)

    return [ave, std]

def width_dynamics(colorlist, kappa, mod=False, savename=0):
    widths = np.array([])
    for i in range(len(colorlist)):
        differences = [np.max(colorlist[i]) - np.min(colorlist[i])]
        for j in range(kappa):
            shifted = (np.array(colorlist[i]) + j) % kappa
            differences.append(np.max(shifted) - np.min(shifted))
        widths = np.append(widths, np.min(differences))
    if savename:
        plt.plot(widths, 'red')
        plt.ylabel('Widths')
        plt.xlabel('Iterations')
        plt.title('Dynamics of Width over FCA Simulation')
        plt.savefig(savename+'_k'+str(kappa)+'_width.png')
        plt.close()
    
    return widths

def gifmake(frames, name, pickcol=False,kappa=False, duration=125):
    """
    Input: sequence of matrices, name of gif
        Optional: color(pickcol), every kappa(kappa)
    output: gif dynamic with name as gif name
    """
    if not pickcol:
        pickcol = random.sample(fun_colors,1)[0]

    def make_gif(frame): 
        plt.pcolormesh(np.array(frame),
                norm=colors.Normalize(vmin=np.min(frames),vmax=np.max(frames)),cmap=pickcol)
        plt.set_ylim(0,30)
        plt.set_xlim(0,20)
        plt.axis('square')
        plt.axis('off') 
        buf = io.BytesIO()
        plt.savefig(buf, format='png', bbox_inches='tight')
        plt.clf()
        buf.seek(0)
        im = Image.open(buf)
        images.append(im)

    images = []
    for i, adj in enumerate(frames):
        if kappa:
            if i%kappa!=0:
                continue 
        make_gif(adj)

    tail = images[1:]
    images[0].save(name+'.gif', save_all=True, 
            append_images=tail, optimize=False, duration=duration, loop=0)


def width(colors, kappa):
    """
    computes width from a color list
    """
    ordered = list(set(colors)) 
    lordered = len(ordered)
    threshold = floor(kappa/2)
    if ordered == 0:
        assert("Empty array or logic error.")

    elif lordered == 1:
        return 0

    elif lordered == 2:
        dw = ordered[1]-ordered[0]
        if dw > threshold:
            return kappa - dw
        else:
            return dw

    else:
        widths = [ordered[-1]-ordered[0]]
        for i in range(lordered-1):
            widths.append(ordered[i+1]-ordered[i])
        return kappa - max(widths)

    return widths

def simulate_dynamics(G, kappa, type='GH', its = int(pow(2,32)-1), verbose=True, timesec=0, tree=False, no_edges=0):
    # initial conditions
    # blink color and lower bound on post-blink
    colors = []
    init_col = G.get_colors()
    colors.append(init_col)
    # local helper function
    def new_color(vertex):
        neighblist = G.get_neighbor_colors(vertex)
        if G.get_color(vertex) == 0 and any(np.array(neighblist) == 1):
            return 1
        if G.get_color(vertex) == 0 and all(np.array(neighblist) != 1):
            return 0
        else:
            return (G.get_color(vertex) + 1) % 5
    # initial coloring and start time
    current_col = G.get_colors()
    s = time.time()
    for i in range(1, its+1):
        # perform updates for each vertex
        current_col = list(map(new_color, range(0, G.num_nodes())))
        #import pdb; pdb.set_trace()
        # check synchronization -> break and return final list and iterations
        if all(np.array(current_col) == 0):
            if verbose: print("Iterations: ",i)
            if no_edges:
                return np.array([-1, init_col, 1, colors, i])
            colors.append(current_col)
            return np.array([G.edges, init_col, 1, colors, i])
        if timesec and time.time()-s > timesec:
            if verbose:
                print("Iterations: ",i)
                print("Time has been reached: ", timesec,"sec.")
            if no_edges:
                return np.array([-1, init_col, 0, colors, i])
            return np.array([G.edges, init_col, 0, colors, i])
        # update to new colors
        G.set_colors(current_col)
        colors.append(np.array(G.get_colors()))
        if tree:
            values, parentlist = tree_iter(G, values, parentlist)
            tree = not (len(G.edges) == G.num_nodes()-1)
            if (len(G.edges)<G.num_nodes()-1):
                print("deleted too many edges")
    if verbose:
        print("Max iterations reached: ", its)
    if no_edges:
        return np.array([-1, init_col, 0, colors, i])
    return np.array([G.edges, init_col, 0, colors, i])
